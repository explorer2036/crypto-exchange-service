package api

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"

	"github.com/sirupsen/logrus"
	_ "github.com/thrasher-corp/gocryptotrader/exchanges/binance"
	"github.com/valyala/fasthttp"
)

type OrderPOST struct {
	Exchange string  `json:"exchange" validate:"required"` // always lowercase
	MarketID string  `json:"marketId" validate:"required"` // native id the exchange uses for that particular market/pair/etc.
	Side     string  `json:"side" validate:"required"`     // (buy/sell)
	Quantity float64 `json:"quantity" validate:"gte=0"`    // the quantity to buy/sell
	Price    uint64  `json:"price"`                        // if zero, send the market order
}

func (s *Server) JSONWrite(ctx *fasthttp.RequestCtx, v interface{}) {
	data, err := json.Marshal(v)
	if err != nil {
		ctx.Error(err.Error(), fasthttp.StatusInternalServerError)
		return
	}
	fmt.Fprintf(ctx, "%s", data)
}

func (s *Server) Order(ctx *fasthttp.RequestCtx) {
	var request OrderPOST
	if err := json.Unmarshal(ctx.PostBody(), &request); err != nil {
		ctx.Error("Invalid order request", fasthttp.StatusBadRequest)
		return
	}

	if err := s.validate.Struct(request); err != nil {
		ctx.Error(fmt.Sprintf("Validate: %v", err), fasthttp.StatusBadRequest)
		return
	}

	side := strings.ToUpper(request.Side)
	quantity := strconv.FormatFloat(request.Quantity, 'f', -1, 32)
	price := strconv.FormatUint(request.Price, 10)
	logrus.Infof("quantity: %s, price: %s", quantity, price)
	id, ts, err := s.binanceWrapper.CreateOrder(ctx, request.MarketID, side, quantity, price)
	if err != nil {
		ctx.Error(fmt.Sprintf("Create order: %v", err), fasthttp.StatusInternalServerError)
		return
	}

	s.JSONWrite(ctx, struct {
		Remote    int64 `json:"remoteId"`  // the id exchange assigned to our order
		Timestamp int64 `json:"timestamp"` // ms resolution [generated by exchange]
	}{id, ts})
}
