package api

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"

	"github.com/go-playground/validator/v10"
	"github.com/sirupsen/logrus"
	"github.com/valyala/fasthttp"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"crypto-exchange-service/apis/order"
	"crypto-exchange-service/pkg/api/exchange"
)

type OrderRequest struct {
	Exchange string  `json:"exchange" validate:"required"` // always lowercase
	MarketID string  `json:"marketId" validate:"required"` // native id the exchange uses for that particular market/pair/etc.
	Side     string  `json:"side" validate:"required"`     // (buy/sell)
	Quantity float32 `json:"quantity" validate:"gte=0"`    // the quantity to buy/sell
	Price    int64   `json:"price" validate:"gt=0"`        // if zero, send the market order
}

func (s *Server) JSONWrite(ctx *fasthttp.RequestCtx, v interface{}) {
	data, err := json.Marshal(v)
	if err != nil {
		ctx.Error(err.Error(), fasthttp.StatusInternalServerError)
		return
	}
	fmt.Fprintf(ctx, "%s", data)
}

func (s *Server) Order(ctx *fasthttp.RequestCtx) {
	var request OrderRequest
	if err := json.Unmarshal(ctx.PostBody(), &request); err != nil {
		ctx.Error("Invalid order request", fasthttp.StatusBadRequest)
		return
	}

	if err := s.validate.Struct(request); err != nil {
		ctx.Error(fmt.Sprintf("Validate: %v", err), fasthttp.StatusBadRequest)
		return
	}

	side := strings.ToUpper(request.Side)
	quantity := strconv.FormatFloat(float64(request.Quantity), 'f', -1, 32)
	price := strconv.FormatInt(request.Price, 10)
	logrus.Infof("quantity: %s, price: %s", quantity, price)
	id, ts, err := s.binanceWrapper.CreateOrder(ctx, request.MarketID, side, quantity, price)
	if err != nil {
		ctx.Error(fmt.Sprintf("Create order: %v", err), fasthttp.StatusInternalServerError)
		return
	}

	s.JSONWrite(ctx, struct {
		Remote    int64 `json:"remoteId"`  // the id exchange assigned to our order
		Timestamp int64 `json:"timestamp"` // ms resolution [generated by exchange]
	}{id, ts})
}

type GetOrderRequest struct {
	ID       int64  `json:"id" validate:"gt=0"`
	MarketID string `json:"marketId" validate:"required"`
}

func (s *Server) GetOrder(ctx *fasthttp.RequestCtx) {
	var request GetOrderRequest
	if err := json.Unmarshal(ctx.PostBody(), &request); err != nil {
		ctx.Error("Invalid order request", fasthttp.StatusBadRequest)
		return
	}
	if err := s.validate.Struct(request); err != nil {
		ctx.Error(fmt.Sprintf("Validate: %v", err), fasthttp.StatusBadRequest)
		return
	}

	logrus.Infof("order id: %d", request.ID)
	order, err := s.binanceWrapper.GetOrder(ctx, request.MarketID, request.ID)
	if err != nil {
		ctx.Error(fmt.Sprintf("Get order: %v", err), fasthttp.StatusInternalServerError)
		return
	}

	s.JSONWrite(ctx, order)
}

type CancelOrderRequest struct {
	ID       int64  `json:"id" validate:"gt=0"`
	MarketID string `json:"marketId" validate:"required"`
}

func (s *Server) CancelOrder(ctx *fasthttp.RequestCtx) {
	var request CancelOrderRequest
	if err := json.Unmarshal(ctx.PostBody(), &request); err != nil {
		ctx.Error("Invalid order request", fasthttp.StatusBadRequest)
		return
	}
	if err := s.validate.Struct(request); err != nil {
		ctx.Error(fmt.Sprintf("Validate: %v", err), fasthttp.StatusBadRequest)
		return
	}

	logrus.Infof("order id: %d", request.ID)
	order, err := s.binanceWrapper.CancelOrder(ctx, request.MarketID, request.ID)
	if err != nil {
		ctx.Error(fmt.Sprintf("Cancel order: %v", err), fasthttp.StatusInternalServerError)
		return
	}

	s.JSONWrite(ctx, order)
}

type OrderServiceImpl struct {
	order.UnimplementedOrderServiceServer

	binanceWrapper *exchange.BinanceWrapper
	validate       *validator.Validate
}

func NewOrderServiceImpl(wrapper *exchange.BinanceWrapper) *OrderServiceImpl {
	return &OrderServiceImpl{binanceWrapper: wrapper, validate: validator.New()}
}

func (s *OrderServiceImpl) CreateOrder(ctx context.Context, request *order.CreateOrderRequest) (*order.CreateOrderResponse, error) {
	newOrder := &OrderRequest{
		Exchange: request.Exchange,
		MarketID: request.MarketId,
		Side:     request.Side,
		Quantity: request.Quantity,
		Price:    request.Price,
	}

	if err := s.validate.Struct(newOrder); err != nil {
		return nil, status.Errorf(codes.InvalidArgument, fmt.Sprintf("Validate: %v", err))
	}

	side := strings.ToUpper(newOrder.Side)
	quantity := strconv.FormatFloat(float64(newOrder.Quantity), 'f', -1, 32)
	price := strconv.FormatInt(newOrder.Price, 10)
	logrus.Infof("quantity: %s, price: %s", quantity, price)
	id, ts, err := s.binanceWrapper.CreateOrder(ctx, newOrder.MarketID, side, quantity, price)
	if err != nil {
		return nil, status.Errorf(codes.Internal, fmt.Sprintf("Create order: %v", err))
	}

	return &order.CreateOrderResponse{OrderId: id, Timestamp: ts}, nil
}
